/*
 *  Copyright (c) (2023) SPHINX_ORG
 *  Authors:
 *    - (C kusuma) <thekoesoemo@gmail.com>
 *      GitHub: (https://github.com/chykusuma)
 *  Contributors:
 *    - (Contributor 1) <email1@example.com>
 *      Github: (https://github.com/yourgit)
 *    - (Contributor 2) <email2@example.com>
 *      Github: (https://github.com/yourgit)
 */


/////////////////////////////////////////////////////////////////////////////////////////////////////////
// This code defines a namespace SPHINXKey containing several functions related to key generation and manipulation. Breakdown through each function and understand its purpose:

  // generateKeyPair(): This function generates a hybrid key pair using the generateHybridKeypair() function from the "Hybrid_key.hpp" file. It returns the generated hybrid key pair.

  // generateAddress(const std::string& publicKey, const std::string& contractName): This function takes a public key and a contract name as input. It converts the public key to bytes and calculates the SPHINX-256 hash of the public key using the SPHINXHash::SPHINX_256() function. Then, it generates a unique identifier for the smart contract by combining the contract name and the public key hash. Finally, it converts the unique identifier to a string and returns it as the smart contract address.

  // calculatePublicKey(const std::string& privateKey): This function takes a private key as input. It converts the private key to bytes and generates a hybrid key pair using the generateKeyPair() function. It then retrieves the public key from the hybrid key pair and converts it to a string. The function also performs some additional operations related to signature verification, but it is not clear from the provided code how those operations are relevant. Finally, it returns the calculated public key as a string.

  // printKeyPair(): This function generates a hybrid key pair using the generate_hybrid_keypair() function from the "Hybrid_key.hpp" file. It extracts the public key from the hybrid key pair and assigns it to the publicKey variable. Then, it prints the public key and the SPHINX-256 hash of the public key as the address.

  // The code primarily relies on the functions and structures defined in "Hybrid_key.hpp" to generate and manipulate hybrid key pairs. It also uses functions from "Hash.hpp" and "Sign.hpp" files for hash calculations and signature verification, respectively.

// This code provides functionality for generating hybrid key pairs, calculating addresses from public keys, calculating public keys from private keys, and printing key pairs.
/////////////////////////////////////////////////////////////////////////////////////////////////////////


#include <iostream>
#include <string>
#include "Hybrid_key.hpp"
#include "Hash.hpp"
#include "Sign.hpp"


namespace SPHINXKey {

    HybridKeypair generateKeyPair() {
        HybridKeypair hybridKeyPair = SPHINXHybridKey::generateHybridKeypair();
        return hybridKeyPair;
    }

    std::string generateAddress(const std::string& publicKey, const std::string& contractName) {
        // Convert the public key to bytes
        unsigned char publicKeyBytes[32];
        for (int i = 0; i < 32; i++) {
            publicKeyBytes[i] = publicKey[i];
        }

        // Calculate the SPHINX-256 hash of the public key
        std::string hash = SPHINXHash::SPHINX_256(publicKey);

        // Generate a unique identifier for the smart contract based on the contract name and public key hash
        std::string contractIdentifier = contractName + "_" + hash;

            // The function receives a publicKey and contractName as input parameters.
            // The publicKey is assumed to be a string representation of a public key.
            // The function converts the publicKey string into an array of unsigned char bytes called publicKeyBytes.
            // It then calculates the SPHINX-256 hash of the publicKey using the SPHINXHash::SPHINX_256 function, which likely applies a cryptographic hash function to the publicKeyBytes.
            // Next, a unique identifier for the smart contract is generated by concatenating the contractName and the calculated hash, separated by an underscore. This creates a string called contractIdentifier.
            // Finally, the contractIdentifier string is returned as the smart contract address.

        // Convert the unique identifier to a string and use it as the smart contract address
        std::string address = contractIdentifier;

        return address;
    }

    std::string calculatePublicKey(const std::string& privateKey) {
        // Convert the private key to bytes
        unsigned char privateKeyBytes[32];
        for (int i = 0; i < 32; i++) {
            privateKeyBytes[i] = privateKey[i];
        }

        // Calculate the public key from the private key
        unsigned char publicKeyBytes[32];
        HybridKeypair hybridKeyPair = generateKeyPair();
        std::vector<uint8_t> privateKeyVec(privateKey.begin(), privateKey.end());
        std::vector<uint8_t> publicKey = hybridKeyPair.x25519_key.public_key;

            // This function takes a privateKey string as input.
            // It initializes an array of unsigned char called privateKeyBytes with a size of 32, which is the expected length of the private key in bytes.
            // It loops through each character of the privateKey string and assigns the corresponding byte value to the privateKeyBytes array.
            // Next, the function calls the generateKeyPair function, which returns a HybridKeypair object. This object likely contains the generated public-private key pair.
            // The privateKey string is converted to a std::vector<uint8_t> called privateKeyVec, which is used as an argument in the SPHINXSign::verify_data function.
            // The publicKey is extracted from the HybridKeypair object and stored in a std::vector<uint8_t> called publicKey.
            // The SPHINXSign::verify_data function is called with the privateKeyVec, publicKey.data(), and publicKeyBytes as arguments. This function likely performs some signature verification process.
            // The resulting signature is stored, but it seems to be unused in the subsequent code.
            // Finally, the publicKeyBytes array is converted to a std::string called calculatedPublicKey using reinterpret_cast and specifying the length of 32 bytes.

        std::string signature = SPHINXSign::verify_data(privateKeyVec, publicKey.data(), publicKeyBytes);

        // Convert the public key to a string
        std::string calculatedPublicKey = std::string(reinterpret_cast<char*>(publicKeyBytes), 32);

        return calculatedPublicKey;
    }

    void printKeyPair() {
        // Generate a hybrid key pair
        SPHINXHybridKey::HybridKeypair hybridKeyPair = SPHINXHybridKey::generate_hybrid_keypair();

        // Extract the public key from the hybrid key pair
        std::string publicKey = hybridKeyPair.merged_key.x25519_key.public_key;

        // Print the public key and address
        std::cout << "Public key: " << publicKey << std::endl;
        std::cout << "Address: " << SPHINXHash::SPHINX_256(publicKey) << std::endl;
    }
} // namespace SPHINXKey